# 레코드

- 레코드는 타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성된다.
- 프로듀서가 생성한 레코드가 브로커에 전송되면 오프셋과 타임스탬프가 지정되어 저장된다. 
- 브로커에 한 번 적재된 레코드는 수정할 수 없고 로그 리텐션 기간 또는 용량에 따라서만 삭제된다.
- 타임스탬프 - 카프카 브로커에 저장될 때 브로커 시간을 기준으로 설정되지만 필요에 따라 레코드 생성 시간 또는 그 이전/이후로 설정할 수도 있다.
- 메시지 키 - 메시지 값을 순서대로 처리하거나 메시지 값의 종류를 나타내기 위해 사용한다. 메시지 키를 사용하면 프로듀서가 토픽에 레코드를 전송할 때 메시지 키의 해시값을 토대로 파티션을 지정하게 된다. (= 동일 메시지 키라면 동일 파티션에 들어간다. 다만, 어느 파티션에 지정될 지 알 수 없고 파티션 개수가 변하면 메시지 키와 파티션 매칭이 달라지게 되므로 주의해야 한다.) 메시지 키를 설정하지 않으면 null로 설정되고, 메시지 키가 null인 레코드는 [기본 설정 파티셔너](https://github.com/apache/kafka/blob/50ca2c8c73b1d9a77c46c1f88e83254ec4bcb821/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java#L37)에 따라 파티션에 분배된다.  

🔹 현재 Kafka의 기본 설정 파티셔너는?
Kafka 3.0 이상부터는 다음과 같은 Sticky Partitioning 기반의 파티셔너가 **기본(Default)**으로 사용
> org.apache.kafka.clients.producer.internals.UniformStickyPartitioner
이 파티셔너는 KIP-794에 의해 도입되었고, 이전 DefaultPartitioner는 더 이상 권장되지 않음

🔹 새로운 기본 파티셔너는 어떻게 다를까?
UniformStickyPartitioner는 KIP-794에 따라 다음과 같이 동작
- Key가 없을 경우 → 배치가 끝날 때까지 동일한 파티션에 계속 보내서 성능 향상
- Key가 있을 경우 → 기존과 동일하게 Key 해시 기반으로 파티션 선택
> 즉, 스티키 파티셔닝을 더 적극적으로 활용해서 throughput과 성능을 높이는 전략!!


- 메시지 키와 메시지 값은 직렬화되어 브로커로 전송된다. 컨슈머는 직렬화와 동일한 형태로 역직렬화를 수행해야 한다. 
- 컨슈머 그룹은 오프셋을 사용해 파티션의 데이터를 어디까지 가져갔는지 확인한다.
- 헤더는 키/값 형태의 메타데이터를 포함한다. 레코드의 속성(스키마 버전 등)을 저장해 컨슈머에서 참조할 수 있다.
