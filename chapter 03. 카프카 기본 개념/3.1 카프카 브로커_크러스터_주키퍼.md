# 카프카 브로커 / 클러스터 / 주키퍼

### 카프카 브로커
- 하나의 서버에는 한 개의 카프카 브로커 프로세스가 실행된다.
- 세 대이상을 묶어서 클러스터로 운영한다.
- 데이터를 전달받아 토픽의 파티션에 데이터를 저장하고, 전달한다.
- 데이터는 파일 시스템에 저장된다.


### 데이터 저장
- 'config/server.properties'의 log.dir 옵션에 정의한 디렉토리에 데이터가 저장된다.
- 토픽 이름과 파티션 번호의 조합으로하위 디렉토리를 생성하여 데이터를 저장한다.
- log에는 메시지와 메타데이터를 저장한다.
- 카프카는 데이터를 메모리나 데이터베이스가 아니라 파일에 저장한다. 페이지 캐시(page cache)를 사용해 디스크 입출력 속도를 높였다. 한 번 읽은 파일의 내용은 메모리의 페이지 캐시 영역에 저장된다. JVM 상에서 동작하는 카프카가 직접 캐시를 구현하는 게 아니다. (그랬더라면 gc가 자주 일어났을 것이다.) 그래서 카프카 힙 사이즈를 크게 설정하지 않아도 된다.

### 데이터 복제 replication
- 복제는 파티션 단위로 이루어진다.
- 토픽 생성 시 파티션의 복제 개수도 같이 설정한다. replicaiton factor. 설정하지않으면 브로커 설정을 따라간다.
- 데이터가 유실되어도 되고 데이터 처리 속도가 중요하다면 개수를 1 또는 2로 설정하기도 한다.
- 데이터 종류마다 다른 복제 개수를 설정하고 상황에 따라서는 토픽마다 복제 개수를 다르게 설정하기도 한다.
- 복제된 파티션은 leader와 follower로 구성된다.
  - 리더: 프로듀서 또는 컨슈머와 직접 통신하는 파티션
  - 팔로워: 복제 데이터를 가지고 있는 파티션.  리더의 오프셋을 확인해서 자신의 오프셋과 차이 나는 경우 데이터를 가져온다.
    <img width="406" alt="image" src="https://github.com/user-attachments/assets/5dca8628-ee5f-49e6-852d-080abcd26576" />

### 컨트롤러
- 클러스터의 여러 브로커 중 한 대가 컨트롤러 역할을 한다.
- 컨트롤러는 다른 브로커들의 상태를 체크하고 브로커가 클러스터에서 빠지는 경우 해당 브로커에 존재하는 리더 파티션을 재분배한다.

### 데이터 삭제
- 카프카는 다른 메시징 플랫폼과 다르게 컨슈머가 데이터를 가져가도 토픽의 데이터가 삭제되지 않는다. 컨슈머나 프로듀서가 데이터 삭제를 요청할 수도 없다. 오직 브로커만이 데이터를 삭제할 수 있다.
- 데이터 삭제는 파일 단위, '로그 세그먼트' 단위로 이뤄진다. 세그먼트는 일반 데이터베이스처럼 특정 데이터만 선별해 삭제할 수 없다.
- 세그먼트는 데이터가 쌓이는 동안 파일 시스템으로 열려있으며, 카프카 브로커에 log.segment.bytes 또는 log.segment.ms 옵션에 값이 설정되면 세그먼트 파일이 닫힌다. 기본값은 1GB이다. 너무 적은 용량으로 설정하면 데이터를 저장하는 동안 세그먼트 파일을 자주 여닫아서 부하가 생길 수 있다. 
- 데이터를 삭제하지 않고 메시지 키를 기준으로 오래된 데이터를 압축하는 정책을 선택할 수도 있다.

### 컨슈머 오프셋 저장
- 컨슈머 그룹은 토픽이 특정 파티션으로부터 데이터를 가져가서 처리하고 이 파티션의 어느 레코드까지 가져갔는지 확인을 위해 오프셋을 커밋한다. 커밋한 오프셋은 '__consumer_offsets' 토픽에 저장된다. 
- 코디네이터 coordinator

### 주키퍼 zeekeeper
- 카프카의 메타데이터를 관리한다.
    - ❓ 메타 데이터는 뭐지?
        - 브로커 정보(어느 보안 규칙으로 통신하는지, jmx port 상태 정보, host 정보 등),
        - 컨트롤러 정보,
        - 토픽 정보 등
          - __consumser_offsets 이라는 토픽은 카프카 내부에서 컨슈머 오프셋을 저장하기 위한 용도로 사용되는 토픽!
- 카프카 서버에서 직접 주키퍼에 붙으려면 카프카 서버에서 실행되고 있는 주키퍼에 연결해야 한다. 

- 클러스터의 여러 브로커 중 한 대가 코디네이터 역할을 한다.
- 코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매칭되도록 분배한다. 컨슈머가 컨슈머 그룹에서 빠지면 매칭되지 않은 파티션을 정상 동작하는 컨슈머로 할당하여 끊임없이 데이터가 처리되도록 도와준다. (=리밸런스 rebalance)  
  <img width="417" alt="image" src="https://github.com/user-attachments/assets/2a6c4dec-50bb-4263-acfa-c3d12dc31e89" />

